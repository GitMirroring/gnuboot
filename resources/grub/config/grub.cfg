# shellcheck disable=SC2148 # Does not check for #!
# Copyright (C) 2013, 2024-2025 Denis 'GNUtoo' Carikli <GNUtoo@cyberdimension.org>
# Copyright (C) 2013-2016, 2020-2021 Leah Rowe <leah@libreboot.org>
# Copyright (C) 2021 Vitali64 <vitali64pmemail@protonmail.com>
# Copyright (C) 2023 Adrien 'neox' Bourmault <neox@gnu.org>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

# shellcheck disable=SC2121 # warn against set var=val
# shellcheck disable=SC1036 # error: invalid '('
# shellcheck disable=SC1088 # error: invalid uses of parentheses

####################
# Global variables #
####################
set default="0"
set gfxpayload=keep
set grub_scan_disk="both"
set pager=1
set prefix=(memdisk)/boot/grub
set timeout=10

###################
# Local variables #
###################
# GRUB doesn't seem to have a way to create local variables, and we don't
# want to introduce bugs like with the following code:
#     devices="(ahci0)"
#     # function that puts the results of (*) in the ${new_devices} variables,
#     # but while doing so it also modifies the $devices variable.
#     scan_devices new_devices
#     if [ "${devices}" = "${new_devices}" ] ; then [...] ; fi
#
# Since function names are unique, to emulate local variables, we use
# _<function name>_<variable_name> as variable names within a given
# function. These variables should never be set in other functions.

insmod at_keyboard
insmod usb_keyboard
insmod nativedisk
insmod ehci
insmod ohci
insmod uhci
insmod usb
insmod usbms
insmod regexp

terminal_input --append at_keyboard
terminal_input --append usb_keyboard
terminal_output --append cbmemc
terminal_output --append gfxterm

if [ -f (cbfsdisk)/background.png ]; then
	insmod png
	background_image (cbfsdisk)/background.png
elif [ -f (cbfsdisk)/background.jpg ]; then
	insmod jpeg
	background_image (cbfsdisk)/background.jpg
fi

keymap usqwerty

function try_cfg {
	set root="${1}"
	for _try_cfg_dir in boot grub grub2 boot/grub boot/grub2; do
		for _try_cfg_name in \
			gnuboot_ osboot_ autoboot_ coreboot_ '' ; do
			if [ -f /"${_try_cfg_dir}"/"${_try_cfg_name}"grub.cfg ]; then
				unset superusers
				configfile \
					/"${_try_cfg_dir}"/"${_try_cfg_name}"grub.cfg
			fi
		done
	done
}

function find_grub {
	echo -n "Attempting to load grub.cfg from '${1}' devices"
	for _find_grub_i in 0 1 2 3 4 5 6 7 8 9 10 11; do
		for _find_grub_p in \
			1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20; do
			try_cfg "(${1}${_find_grub_i},${_find_grub_p})"
		done
		# raw devices e.g. (ahci0) instead of (ahci0,1)
		try_cfg "(${1}${_find_grub_i})"
	done
	echo # Insert newline
}

function try_isolinux_cfg {
	set root="${1}"
	for _try_isolinux_dir in '' /boot; do
		if [ -f "${_try_isolinux_dir}"/isolinux/isolinux.cfg ]; then
			syslinux_configfile -i \
				"${_try_isolinux_dir}"/isolinux/isolinux.cfg
		elif [ -f "${_try_isolinux_dir}"/syslinux/syslinux.cfg ]; then
			syslinux_configfile -s \
				"${_try_isolinux_dir}"/syslinux/syslinux.cfg
		fi
	done
}

function find_isolinux {
	echo "\nAttempting to parse isolinux/syslinux config from '${1}' devices"
	for _find_isolinux_i in 0 1 2 3 4 5 6 7 8 9 10 11; do
		for _find_isolinux_p in \
			1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20; do
			try_isolinux_cfg \
				"(${1}${_find_isolinux_i},${_find_isolinux_p})"
		done
		# raw devices e.g. (usb0) instead of (usb0,1)
		try_isolinux_cfg "(${1}${_find_isolinux_i})"
	done
	echo # Insert newline
}

function load_os {
	if [ "${grub_scan_disk}" != "ata" ]; then
		find_grub ahci
	fi
	if [ "${grub_scan_disk}" != "ahci" ]; then
		find_grub ata
	fi

	for _load_os_device in (*) ; do
		if regexp "^\(lvm/" "${_load_os_device}" ; then
			try_cfg "${_load_os_device}"
		fi
	done

	_load_os_raidvol="md/0 md/1 md/2 md/3 md/4 md/5 md/6 md/7 md/8 md/9"

	# in practise, doing multiple redundant checks is perfectly fast and
	# TODO: optimize grub itself, and use */? here for everything

	for _load_os_vol in ${_load_os_raidvol} ; do
		try_cfg "${_load_os_vol}"
	done

	unset _load_os_ahci
	unset _load_os_ata
	for _load_os_i in 11 10 9 8 7 6 5 4 3 2 1 0; do
		for _load_os_p in \
			20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1; do
			if [ "${grub_scan_disk}" != "ata" ]; then
				_load_os_ahci="(ahci${_load_os_i},${_load_os_p}) ${_load_os_ahci}"
			fi
			if [ "${grub_scan_disk}" != "ahci" ]; then
				_load_os_ata="(ata${i},${_load_os_p}) ${_load_os_ata}"
			fi
		done
	done

	set pager=0
	echo -n "Attempting to unlock encrypted volumes"
	for _load_os_device in ${_load_os_ahci} \
					${_load_os_ata} \
					${_load_os_raidvol}; do
		if cryptomount "${_load_os_device}" ; then break ; fi
	done

	for _load_os_device in (*) ; do
		if regexp "^\(lvm/" "${_load_os_device}" ; then
			if cryptomount "${_load_os_device}" ; then break ; fi
		fi
	done


	set pager=1
	echo

	# after cryptomount, lvm volumes might be available
	for _load_os_device in (*) ; do
		if regexp "^\(lvm/" "${_load_os_device}" ; then
			try_cfg "${_load_os_device}"
		fi
	done

	find_grub crypto

	if [ "${grub_scan_disk}" != "ata" ]; then
		# Last resort, if all else fails
		set root=ahci0,1
		for _load_os_p in / /boot/; do
			if [ -f "${_load_os_p}vmlinuz" ]; then
				linux ${_load_os_p}vmlinuz root=/dev/sda1 rw
				if [ -f "${_load_os_p}initrd.img" ]; then
					initrd ${_load_os_p}initrd.img
				fi
			fi
		done
	fi

	if [ "${grub_scan_disk}" != "ahci" ]; then
		# Last resort (for setups that use IDE instead of SATA)
		set root=ata0,1
		for _load_os_p in / /boot/; do
			if [ -f "${_load_os_p}vmlinuz" ]; then
				linux ${_load_os_p}vmlinuz root=/dev/sda1 rw
				if [ -f "${_load_os_p}initrd.img" ]; then
					initrd ${_load_os_p}initrd.img
				fi
			fi
		done
	fi

	# Prevent pager requiring to accept each line instead of whole screen
	true
}

menuentry 'Load Operating System (incl. fully encrypted disks)  [o]' --hotkey='o' {
	load_os
}

menuentry 'Search ISOLINUX menu (AHCI)  [a]' --hotkey='a' {
	find_isolinux ahci
}
menuentry 'Search ISOLINUX menu (USB)  [u]' --hotkey='u' {
	find_isolinux usb
}
menuentry 'Search ISOLINUX menu (ATA/IDE)  [d]' --hotkey='d' {
	find_isolinux ata
}
menuentry 'Load test configuration (grubtest.cfg) inside of CBFS  [t]' --hotkey='t' {
	set root='(cbfsdisk)'
	if [ -f /grubtest.cfg ]; then
		configfile /grubtest.cfg
	fi
}
menuentry 'Search for GRUB2 configuration on external media  [s]' --hotkey='s' {
	find_grub usb
}
if [ -f (cbfsdisk)/seabios.elf ]; then
menuentry 'Load SeaBIOS (payload) [b]' --hotkey='b' {
	set root='cbfsdisk'
	chainloader /seabios.elf
}
fi
if [ -f (cbfsdisk)/img/grub2 ]; then
menuentry 'Return to SeaBIOS [b]' --hotkey='b' {
	set root='cbfsdisk'
	chainloader /fallback/payload
}
fi
menuentry 'Poweroff  [p]' --hotkey='p' {
	halt
}
menuentry 'Reboot  [r]' --hotkey='r' {
	reboot
}
if [ -f (cbfsdisk)/img/memtest ]; then
menuentry 'Load MemTest86+  [m]' --hotkey='m' {
	set root='cbfsdisk'
	chainloader /img/memtest
}
fi
