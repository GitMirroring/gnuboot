#!/usr/bin/env bash

#  generic build script, for building components (all of them)
#
#	Copyright (C) 2014, 2015, 2020, 2021 Leah Rowe <info@minifree.org>
#	Copyright (C) 2015 Patrick "P. J." McDermott <pj@pehjota.net>
#	Copyright (C) 2015, 2016 Klemens Nanni <contact@autoboot.org>
#	Copyright (C) 2022, Caleb La Grange <thonkpeasant@protonmail.com>
#
#	This program is free software: you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation, either version 3 of the License, or
#	(at your option) any later version.
#
#	This program is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.
#
#	You should have received a copy of the GNU General Public License
#	along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
./.gitcheck

[ "${DEBUG+set}" = 'set' ] && set -v
set -u -e

projectname="$(cat projectname)"

. resources/scripts/misc/sysexits.sh

# This is for backward compatibility: before the list of "modes" was
# auto-detected, but there isn't a 1:1 matching between modes and
# packages tasks (build, clean, etc).
tasks="\
	boot \
	clean \
	dependencies \
	descriptors \
	distclean \
	install \
	module \
	payload \
	release \
"

list_tasks() {
	for task in ${tasks} ; do
		echo "${task}"
	done
}

list_tasks_paths() {
	task="${1}"

	find resources/packages \
		-mindepth 2 -maxdepth 2 \
		-type f \
		-name "${task}" \
		-printf "%P\n"
}

# Takes exactly one task as parameter
list_packages() {
	task="${1}"

	list_tasks_paths "${task}" | \
		sed 's#/.*##'
}

help() {
	cat <<- EOF
	Usage:
	        ./build <TASK> <PACKAGE>
	        ./build --help

	possible values for 'task':
	$(list_tasks)

	Example:	./build module all
	Example:	./build module flashrom [static]
	Example:	./build roms withgrub
	Example:	./build clean all

	Refer to the ${projectname} documentation for more information.
	EOF
}

die() {
	ret="$1"
	shift 1

	printf 'Error: %s\n' "${@}" 1>&2
	exit "${ret}"
}

if [ $# -lt 1 ]; then
    die "${EX_USAGE}" \
	"Wrong number of arguments specified. See './build --help'."
fi

task="${1}"

if [ "${task}" != "dependencies" ]; then
	./resources/scripts/misc/versioncheck
fi

[ "${task}" = "--help" ] && help && exit 0

if [ $# -gt 1 ]; then

	package="${2}"
	shift 2

	case "${package}" in
		list)
			tasks_paths=$(list_tasks_paths "${task}")
			if [ -z "${tasks_paths}" ] ; then
				die "${EX_USAGE}" \
				    "Invalid task '${task}'." \
				    " See './build --help'."
			else
				printf "Available packages for task '%s':\n\n" \
				   "${task}"
				list_packages "${task}"
			fi
			;;
		all)
			for package in $(list_packages "${task}"); do
				# shellcheck disable=SC2068
				resources/packages/"${package}"/"${task}" $@
			done
			;;
		*)
			if [ -d resources/packages/"${package}" ] ; then
				pkg_dir=resources/packages/"${package}"
				if [ -f "${pkg_dir}"/"${task}" ]; then
					# shellcheck disable=SC2068
					"${pkg_dir}"/"${task}" $@
				else
					help
					die "${EX_USAGE}" \
					    "Invalid package for '${task}'." \
					    " See './build ${task} list'."
				fi
			else
				help
				die "${EX_USAGE}" \
				    "Invalid task '${task}'." \
				    " See './build --help'."
			fi
	esac
else
	help
	exit 0
fi

./.gitcheck clean
